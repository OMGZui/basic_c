# 线程

## 1、线程概念

UNIX进程可以看成只有一个控制线程：`一个进程在某一时刻只能做一件事情`

有了`多个控制线程`后，在程序设计时可以把进程设计成在`某一时刻做多件事情`

- 每个线程有一个线程ID，与进程唯一ID不同，线程ID只有在它所属的进程上下文才有意义
- `进程ID`是用`pid_t非负整数`表示，而`线程ID`是用`pthread_t数据类型`来表示

```c
#include <pthread.h>

int pthread_equal(pthread_t tid1, pthread_t tid2) 线程ID比较
pthread_t pthread_self(void) 获取自身线程ID
int pthread_create() 创建线程

```

- 新创建的线程并不能保证哪个线程会先运行，同时可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字

## 2、线程终止

单个线程可以有3中方式退出：

1. 线程可以简单的从启动例程中返回，返回值是线程的退出码
2. 线程可以被同一进程中的其他线程取消
3. 线程调用pthread_exit

```c
#include <pthread.h>

void pthread_exit(void *rval_ptr) rval_ptr是一个无类型指针
int pthread_join(pthread_t thread, void **rval_ptr) 可以访问到rval_ptr指针
int pthread_cancel(pthread_t tid) 取消同一进程中的其他线程
```

## 3、线程同步

两个线程对同一变量进程读写操作会导致得到的值不一致，这时就需要使用`锁`

`互斥量mutex`本质上是一把锁，在访问共享资源前设置(加锁)，在访问结束后释放(解锁)

其它线程访问已经加锁的资源会被阻塞，直到解锁

```c
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *restrict mutex) 初始化
int pthread_mutex_destroy(pthread_mutex_t *mutex) 销毁

int pthread_mutex_lock(pthread_mutex_t *mutex) 加锁
int pthread_mutex_trylock(pthread_mutex_t *mutex) 尝试加锁
int pthread_mutex_unlock(pthread_mutex_t *mutex) 解锁
```

`读写锁reader-writer-lock`与互斥量类似，但是允许更高的并行性

- 读
- 写
- 无

```c
#include <pthread.h>

int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock) 初始化
int pthread_rwlock_destroy(pthread_rwlock_t *restrict rwlock) 销毁

int pthread_rwlock_rdlock(pthread_rwlock_t *restrict rwlock) 读锁
int pthread_rwlock_tryrdlock(pthread_rwlock_t *restrict rwlock) 尝试读锁
int pthread_rwlock_wrlock(pthread_rwlock_t *restrict rwlock) 写锁
int pthread_rwlock_trywrlock(pthread_rwlock_t *restrict rwlock) 尝试写锁
int pthread_rwlock_unlock(pthread_rwlock_t *restrict rwlock) 解锁

```

`条件变量` pthread_cond_init

`自旋锁` pthread_spin_init

`屏障` pthread_barrier_init

## 4、线程控制
